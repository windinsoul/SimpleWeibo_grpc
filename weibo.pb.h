// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: weibo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_weibo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_weibo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_weibo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_weibo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_weibo_2eproto;
namespace weibo {
class GetHotPostReq;
struct GetHotPostReqDefaultTypeInternal;
extern GetHotPostReqDefaultTypeInternal _GetHotPostReq_default_instance_;
class GetPostByUserIdReq;
struct GetPostByUserIdReqDefaultTypeInternal;
extern GetPostByUserIdReqDefaultTypeInternal _GetPostByUserIdReq_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRes;
struct LoginResDefaultTypeInternal;
extern LoginResDefaultTypeInternal _LoginRes_default_instance_;
class PostFeedReq;
struct PostFeedReqDefaultTypeInternal;
extern PostFeedReqDefaultTypeInternal _PostFeedReq_default_instance_;
class PostRes;
struct PostResDefaultTypeInternal;
extern PostResDefaultTypeInternal _PostRes_default_instance_;
class PublishPostReq;
struct PublishPostReqDefaultTypeInternal;
extern PublishPostReqDefaultTypeInternal _PublishPostReq_default_instance_;
class PublishPostRes;
struct PublishPostResDefaultTypeInternal;
extern PublishPostResDefaultTypeInternal _PublishPostRes_default_instance_;
class RegistReq;
struct RegistReqDefaultTypeInternal;
extern RegistReqDefaultTypeInternal _RegistReq_default_instance_;
class RegistRes;
struct RegistResDefaultTypeInternal;
extern RegistResDefaultTypeInternal _RegistRes_default_instance_;
}  // namespace weibo
PROTOBUF_NAMESPACE_OPEN
template<> ::weibo::GetHotPostReq* Arena::CreateMaybeMessage<::weibo::GetHotPostReq>(Arena*);
template<> ::weibo::GetPostByUserIdReq* Arena::CreateMaybeMessage<::weibo::GetPostByUserIdReq>(Arena*);
template<> ::weibo::LoginReq* Arena::CreateMaybeMessage<::weibo::LoginReq>(Arena*);
template<> ::weibo::LoginRes* Arena::CreateMaybeMessage<::weibo::LoginRes>(Arena*);
template<> ::weibo::PostFeedReq* Arena::CreateMaybeMessage<::weibo::PostFeedReq>(Arena*);
template<> ::weibo::PostRes* Arena::CreateMaybeMessage<::weibo::PostRes>(Arena*);
template<> ::weibo::PublishPostReq* Arena::CreateMaybeMessage<::weibo::PublishPostReq>(Arena*);
template<> ::weibo::PublishPostRes* Arena::CreateMaybeMessage<::weibo::PublishPostRes>(Arena*);
template<> ::weibo::RegistReq* Arena::CreateMaybeMessage<::weibo::RegistReq>(Arena*);
template<> ::weibo::RegistRes* Arena::CreateMaybeMessage<::weibo::RegistRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace weibo {

// ===================================================================

class PublishPostRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.PublishPostRes) */ {
 public:
  inline PublishPostRes() : PublishPostRes(nullptr) {}
  ~PublishPostRes() override;
  explicit PROTOBUF_CONSTEXPR PublishPostRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishPostRes(const PublishPostRes& from);
  PublishPostRes(PublishPostRes&& from) noexcept
    : PublishPostRes() {
    *this = ::std::move(from);
  }

  inline PublishPostRes& operator=(const PublishPostRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishPostRes& operator=(PublishPostRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishPostRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishPostRes* internal_default_instance() {
    return reinterpret_cast<const PublishPostRes*>(
               &_PublishPostRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublishPostRes& a, PublishPostRes& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishPostRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishPostRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishPostRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishPostRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishPostRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishPostRes& from) {
    PublishPostRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishPostRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.PublishPostRes";
  }
  protected:
  explicit PublishPostRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultCodeFieldNumber = 1,
  };
  // bool result_code = 1;
  void clear_result_code();
  bool result_code() const;
  void set_result_code(bool value);
  private:
  bool _internal_result_code() const;
  void _internal_set_result_code(bool value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.PublishPostRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class PublishPostReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.PublishPostReq) */ {
 public:
  inline PublishPostReq() : PublishPostReq(nullptr) {}
  ~PublishPostReq() override;
  explicit PROTOBUF_CONSTEXPR PublishPostReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishPostReq(const PublishPostReq& from);
  PublishPostReq(PublishPostReq&& from) noexcept
    : PublishPostReq() {
    *this = ::std::move(from);
  }

  inline PublishPostReq& operator=(const PublishPostReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishPostReq& operator=(PublishPostReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishPostReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishPostReq* internal_default_instance() {
    return reinterpret_cast<const PublishPostReq*>(
               &_PublishPostReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PublishPostReq& a, PublishPostReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishPostReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishPostReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishPostReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishPostReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishPostReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishPostReq& from) {
    PublishPostReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishPostReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.PublishPostReq";
  }
  protected:
  explicit PublishPostReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPostTextFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string postText = 2;
  void clear_posttext();
  const std::string& posttext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_posttext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_posttext();
  PROTOBUF_NODISCARD std::string* release_posttext();
  void set_allocated_posttext(std::string* posttext);
  private:
  const std::string& _internal_posttext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_posttext(const std::string& value);
  std::string* _internal_mutable_posttext();
  public:

  // @@protoc_insertion_point(class_scope:weibo.PublishPostReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posttext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class RegistReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.RegistReq) */ {
 public:
  inline RegistReq() : RegistReq(nullptr) {}
  ~RegistReq() override;
  explicit PROTOBUF_CONSTEXPR RegistReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistReq(const RegistReq& from);
  RegistReq(RegistReq&& from) noexcept
    : RegistReq() {
    *this = ::std::move(from);
  }

  inline RegistReq& operator=(const RegistReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistReq& operator=(RegistReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistReq* internal_default_instance() {
    return reinterpret_cast<const RegistReq*>(
               &_RegistReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegistReq& a, RegistReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistReq& from) {
    RegistReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.RegistReq";
  }
  protected:
  explicit RegistReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:weibo.RegistReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class RegistRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.RegistRes) */ {
 public:
  inline RegistRes() : RegistRes(nullptr) {}
  ~RegistRes() override;
  explicit PROTOBUF_CONSTEXPR RegistRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistRes(const RegistRes& from);
  RegistRes(RegistRes&& from) noexcept
    : RegistRes() {
    *this = ::std::move(from);
  }

  inline RegistRes& operator=(const RegistRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistRes& operator=(RegistRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistRes* internal_default_instance() {
    return reinterpret_cast<const RegistRes*>(
               &_RegistRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegistRes& a, RegistRes& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistRes& from) {
    RegistRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.RegistRes";
  }
  protected:
  explicit RegistRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kResultCodeFieldNumber = 3,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // uint32 user_id = 2;
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // uint32 result_code = 3;
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.RegistRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    uint32_t user_id_;
    uint32_t result_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit PROTOBUF_CONSTEXPR LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReq& from) {
    LoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:weibo.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class LoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.LoginRes) */ {
 public:
  inline LoginRes() : LoginRes(nullptr) {}
  ~LoginRes() override;
  explicit PROTOBUF_CONSTEXPR LoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRes(const LoginRes& from);
  LoginRes(LoginRes&& from) noexcept
    : LoginRes() {
    *this = ::std::move(from);
  }

  inline LoginRes& operator=(const LoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRes& operator=(LoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRes* internal_default_instance() {
    return reinterpret_cast<const LoginRes*>(
               &_LoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginRes& a, LoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRes& from) {
    LoginRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.LoginRes";
  }
  protected:
  explicit LoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kResultCodeFieldNumber = 2,
  };
  // string token = 3;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // uint32 result_code = 2;
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.LoginRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    uint32_t user_id_;
    uint32_t result_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class GetHotPostReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.GetHotPostReq) */ {
 public:
  inline GetHotPostReq() : GetHotPostReq(nullptr) {}
  ~GetHotPostReq() override;
  explicit PROTOBUF_CONSTEXPR GetHotPostReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHotPostReq(const GetHotPostReq& from);
  GetHotPostReq(GetHotPostReq&& from) noexcept
    : GetHotPostReq() {
    *this = ::std::move(from);
  }

  inline GetHotPostReq& operator=(const GetHotPostReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHotPostReq& operator=(GetHotPostReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHotPostReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHotPostReq* internal_default_instance() {
    return reinterpret_cast<const GetHotPostReq*>(
               &_GetHotPostReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetHotPostReq& a, GetHotPostReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHotPostReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHotPostReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHotPostReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHotPostReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHotPostReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHotPostReq& from) {
    GetHotPostReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHotPostReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.GetHotPostReq";
  }
  protected:
  explicit GetHotPostReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPostMaxRankFieldNumber = 1,
  };
  // uint32 post_max_rank = 1;
  void clear_post_max_rank();
  uint32_t post_max_rank() const;
  void set_post_max_rank(uint32_t value);
  private:
  uint32_t _internal_post_max_rank() const;
  void _internal_set_post_max_rank(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.GetHotPostReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t post_max_rank_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class PostRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.PostRes) */ {
 public:
  inline PostRes() : PostRes(nullptr) {}
  ~PostRes() override;
  explicit PROTOBUF_CONSTEXPR PostRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostRes(const PostRes& from);
  PostRes(PostRes&& from) noexcept
    : PostRes() {
    *this = ::std::move(from);
  }

  inline PostRes& operator=(const PostRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostRes& operator=(PostRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostRes* internal_default_instance() {
    return reinterpret_cast<const PostRes*>(
               &_PostRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PostRes& a, PostRes& b) {
    a.Swap(&b);
  }
  inline void Swap(PostRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostRes& from) {
    PostRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.PostRes";
  }
  protected:
  explicit PostRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kAuthorNameFieldNumber = 3,
    kPublishTimeFieldNumber = 5,
    kPostIdFieldNumber = 1,
    kTransNumsFieldNumber = 4,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string author_name = 3;
  void clear_author_name();
  const std::string& author_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_name();
  PROTOBUF_NODISCARD std::string* release_author_name();
  void set_allocated_author_name(std::string* author_name);
  private:
  const std::string& _internal_author_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_name(const std::string& value);
  std::string* _internal_mutable_author_name();
  public:

  // string publish_time = 5;
  void clear_publish_time();
  const std::string& publish_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publish_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publish_time();
  PROTOBUF_NODISCARD std::string* release_publish_time();
  void set_allocated_publish_time(std::string* publish_time);
  private:
  const std::string& _internal_publish_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publish_time(const std::string& value);
  std::string* _internal_mutable_publish_time();
  public:

  // uint32 post_id = 1;
  void clear_post_id();
  uint32_t post_id() const;
  void set_post_id(uint32_t value);
  private:
  uint32_t _internal_post_id() const;
  void _internal_set_post_id(uint32_t value);
  public:

  // int32 trans_nums = 4;
  void clear_trans_nums();
  int32_t trans_nums() const;
  void set_trans_nums(int32_t value);
  private:
  int32_t _internal_trans_nums() const;
  void _internal_set_trans_nums(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.PostRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publish_time_;
    uint32_t post_id_;
    int32_t trans_nums_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class GetPostByUserIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.GetPostByUserIdReq) */ {
 public:
  inline GetPostByUserIdReq() : GetPostByUserIdReq(nullptr) {}
  ~GetPostByUserIdReq() override;
  explicit PROTOBUF_CONSTEXPR GetPostByUserIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPostByUserIdReq(const GetPostByUserIdReq& from);
  GetPostByUserIdReq(GetPostByUserIdReq&& from) noexcept
    : GetPostByUserIdReq() {
    *this = ::std::move(from);
  }

  inline GetPostByUserIdReq& operator=(const GetPostByUserIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPostByUserIdReq& operator=(GetPostByUserIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPostByUserIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPostByUserIdReq* internal_default_instance() {
    return reinterpret_cast<const GetPostByUserIdReq*>(
               &_GetPostByUserIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetPostByUserIdReq& a, GetPostByUserIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPostByUserIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPostByUserIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPostByUserIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPostByUserIdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPostByUserIdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPostByUserIdReq& from) {
    GetPostByUserIdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPostByUserIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.GetPostByUserIdReq";
  }
  protected:
  explicit GetPostByUserIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // uint32 user_id = 1;
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.GetPostByUserIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// -------------------------------------------------------------------

class PostFeedReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:weibo.PostFeedReq) */ {
 public:
  inline PostFeedReq() : PostFeedReq(nullptr) {}
  ~PostFeedReq() override;
  explicit PROTOBUF_CONSTEXPR PostFeedReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostFeedReq(const PostFeedReq& from);
  PostFeedReq(PostFeedReq&& from) noexcept
    : PostFeedReq() {
    *this = ::std::move(from);
  }

  inline PostFeedReq& operator=(const PostFeedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostFeedReq& operator=(PostFeedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostFeedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostFeedReq* internal_default_instance() {
    return reinterpret_cast<const PostFeedReq*>(
               &_PostFeedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PostFeedReq& a, PostFeedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PostFeedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostFeedReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostFeedReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostFeedReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostFeedReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostFeedReq& from) {
    PostFeedReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostFeedReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "weibo.PostFeedReq";
  }
  protected:
  explicit PostFeedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kEachFlushPostNumFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int32 each_flush_post_num = 1;
  void clear_each_flush_post_num();
  int32_t each_flush_post_num() const;
  void set_each_flush_post_num(int32_t value);
  private:
  int32_t _internal_each_flush_post_num() const;
  void _internal_set_each_flush_post_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:weibo.PostFeedReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int32_t each_flush_post_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_weibo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublishPostRes

// bool result_code = 1;
inline void PublishPostRes::clear_result_code() {
  _impl_.result_code_ = false;
}
inline bool PublishPostRes::_internal_result_code() const {
  return _impl_.result_code_;
}
inline bool PublishPostRes::result_code() const {
  // @@protoc_insertion_point(field_get:weibo.PublishPostRes.result_code)
  return _internal_result_code();
}
inline void PublishPostRes::_internal_set_result_code(bool value) {
  
  _impl_.result_code_ = value;
}
inline void PublishPostRes::set_result_code(bool value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:weibo.PublishPostRes.result_code)
}

// -------------------------------------------------------------------

// PublishPostReq

// string token = 1;
inline void PublishPostReq::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PublishPostReq::token() const {
  // @@protoc_insertion_point(field_get:weibo.PublishPostReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishPostReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PublishPostReq.token)
}
inline std::string* PublishPostReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:weibo.PublishPostReq.token)
  return _s;
}
inline const std::string& PublishPostReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PublishPostReq::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishPostReq::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishPostReq::release_token() {
  // @@protoc_insertion_point(field_release:weibo.PublishPostReq.token)
  return _impl_.token_.Release();
}
inline void PublishPostReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PublishPostReq.token)
}

// string postText = 2;
inline void PublishPostReq::clear_posttext() {
  _impl_.posttext_.ClearToEmpty();
}
inline const std::string& PublishPostReq::posttext() const {
  // @@protoc_insertion_point(field_get:weibo.PublishPostReq.postText)
  return _internal_posttext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishPostReq::set_posttext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.posttext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PublishPostReq.postText)
}
inline std::string* PublishPostReq::mutable_posttext() {
  std::string* _s = _internal_mutable_posttext();
  // @@protoc_insertion_point(field_mutable:weibo.PublishPostReq.postText)
  return _s;
}
inline const std::string& PublishPostReq::_internal_posttext() const {
  return _impl_.posttext_.Get();
}
inline void PublishPostReq::_internal_set_posttext(const std::string& value) {
  
  _impl_.posttext_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishPostReq::_internal_mutable_posttext() {
  
  return _impl_.posttext_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishPostReq::release_posttext() {
  // @@protoc_insertion_point(field_release:weibo.PublishPostReq.postText)
  return _impl_.posttext_.Release();
}
inline void PublishPostReq::set_allocated_posttext(std::string* posttext) {
  if (posttext != nullptr) {
    
  } else {
    
  }
  _impl_.posttext_.SetAllocated(posttext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.posttext_.IsDefault()) {
    _impl_.posttext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PublishPostReq.postText)
}

// -------------------------------------------------------------------

// RegistReq

// string user_name = 1;
inline void RegistReq::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& RegistReq::user_name() const {
  // @@protoc_insertion_point(field_get:weibo.RegistReq.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistReq::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.RegistReq.user_name)
}
inline std::string* RegistReq::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:weibo.RegistReq.user_name)
  return _s;
}
inline const std::string& RegistReq::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void RegistReq::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistReq::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistReq::release_user_name() {
  // @@protoc_insertion_point(field_release:weibo.RegistReq.user_name)
  return _impl_.user_name_.Release();
}
inline void RegistReq::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.RegistReq.user_name)
}

// string password = 2;
inline void RegistReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegistReq::password() const {
  // @@protoc_insertion_point(field_get:weibo.RegistReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.RegistReq.password)
}
inline std::string* RegistReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:weibo.RegistReq.password)
  return _s;
}
inline const std::string& RegistReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RegistReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistReq::release_password() {
  // @@protoc_insertion_point(field_release:weibo.RegistReq.password)
  return _impl_.password_.Release();
}
inline void RegistReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.RegistReq.password)
}

// -------------------------------------------------------------------

// RegistRes

// string user_name = 1;
inline void RegistRes::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& RegistRes::user_name() const {
  // @@protoc_insertion_point(field_get:weibo.RegistRes.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistRes::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.RegistRes.user_name)
}
inline std::string* RegistRes::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:weibo.RegistRes.user_name)
  return _s;
}
inline const std::string& RegistRes::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void RegistRes::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistRes::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistRes::release_user_name() {
  // @@protoc_insertion_point(field_release:weibo.RegistRes.user_name)
  return _impl_.user_name_.Release();
}
inline void RegistRes::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.RegistRes.user_name)
}

// uint32 user_id = 2;
inline void RegistRes::clear_user_id() {
  _impl_.user_id_ = 0u;
}
inline uint32_t RegistRes::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RegistRes::user_id() const {
  // @@protoc_insertion_point(field_get:weibo.RegistRes.user_id)
  return _internal_user_id();
}
inline void RegistRes::_internal_set_user_id(uint32_t value) {
  
  _impl_.user_id_ = value;
}
inline void RegistRes::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:weibo.RegistRes.user_id)
}

// uint32 result_code = 3;
inline void RegistRes::clear_result_code() {
  _impl_.result_code_ = 0u;
}
inline uint32_t RegistRes::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t RegistRes::result_code() const {
  // @@protoc_insertion_point(field_get:weibo.RegistRes.result_code)
  return _internal_result_code();
}
inline void RegistRes::_internal_set_result_code(uint32_t value) {
  
  _impl_.result_code_ = value;
}
inline void RegistRes::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:weibo.RegistRes.result_code)
}

// -------------------------------------------------------------------

// LoginReq

// string user_name = 1;
inline void LoginReq::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& LoginReq::user_name() const {
  // @@protoc_insertion_point(field_get:weibo.LoginReq.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.LoginReq.user_name)
}
inline std::string* LoginReq::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:weibo.LoginReq.user_name)
  return _s;
}
inline const std::string& LoginReq::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void LoginReq::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_user_name() {
  // @@protoc_insertion_point(field_release:weibo.LoginReq.user_name)
  return _impl_.user_name_.Release();
}
inline void LoginReq::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.LoginReq.user_name)
}

// string password = 2;
inline void LoginReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:weibo.LoginReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.LoginReq.password)
}
inline std::string* LoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:weibo.LoginReq.password)
  return _s;
}
inline const std::string& LoginReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:weibo.LoginReq.password)
  return _impl_.password_.Release();
}
inline void LoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.LoginReq.password)
}

// -------------------------------------------------------------------

// LoginRes

// uint32 user_id = 1;
inline void LoginRes::clear_user_id() {
  _impl_.user_id_ = 0u;
}
inline uint32_t LoginRes::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginRes::user_id() const {
  // @@protoc_insertion_point(field_get:weibo.LoginRes.user_id)
  return _internal_user_id();
}
inline void LoginRes::_internal_set_user_id(uint32_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginRes::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:weibo.LoginRes.user_id)
}

// uint32 result_code = 2;
inline void LoginRes::clear_result_code() {
  _impl_.result_code_ = 0u;
}
inline uint32_t LoginRes::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t LoginRes::result_code() const {
  // @@protoc_insertion_point(field_get:weibo.LoginRes.result_code)
  return _internal_result_code();
}
inline void LoginRes::_internal_set_result_code(uint32_t value) {
  
  _impl_.result_code_ = value;
}
inline void LoginRes::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:weibo.LoginRes.result_code)
}

// string token = 3;
inline void LoginRes::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& LoginRes::token() const {
  // @@protoc_insertion_point(field_get:weibo.LoginRes.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRes::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.LoginRes.token)
}
inline std::string* LoginRes::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:weibo.LoginRes.token)
  return _s;
}
inline const std::string& LoginRes::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginRes::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRes::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRes::release_token() {
  // @@protoc_insertion_point(field_release:weibo.LoginRes.token)
  return _impl_.token_.Release();
}
inline void LoginRes::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.LoginRes.token)
}

// -------------------------------------------------------------------

// GetHotPostReq

// uint32 post_max_rank = 1;
inline void GetHotPostReq::clear_post_max_rank() {
  _impl_.post_max_rank_ = 0u;
}
inline uint32_t GetHotPostReq::_internal_post_max_rank() const {
  return _impl_.post_max_rank_;
}
inline uint32_t GetHotPostReq::post_max_rank() const {
  // @@protoc_insertion_point(field_get:weibo.GetHotPostReq.post_max_rank)
  return _internal_post_max_rank();
}
inline void GetHotPostReq::_internal_set_post_max_rank(uint32_t value) {
  
  _impl_.post_max_rank_ = value;
}
inline void GetHotPostReq::set_post_max_rank(uint32_t value) {
  _internal_set_post_max_rank(value);
  // @@protoc_insertion_point(field_set:weibo.GetHotPostReq.post_max_rank)
}

// -------------------------------------------------------------------

// PostRes

// uint32 post_id = 1;
inline void PostRes::clear_post_id() {
  _impl_.post_id_ = 0u;
}
inline uint32_t PostRes::_internal_post_id() const {
  return _impl_.post_id_;
}
inline uint32_t PostRes::post_id() const {
  // @@protoc_insertion_point(field_get:weibo.PostRes.post_id)
  return _internal_post_id();
}
inline void PostRes::_internal_set_post_id(uint32_t value) {
  
  _impl_.post_id_ = value;
}
inline void PostRes::set_post_id(uint32_t value) {
  _internal_set_post_id(value);
  // @@protoc_insertion_point(field_set:weibo.PostRes.post_id)
}

// string text = 2;
inline void PostRes::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& PostRes::text() const {
  // @@protoc_insertion_point(field_get:weibo.PostRes.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostRes::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PostRes.text)
}
inline std::string* PostRes::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:weibo.PostRes.text)
  return _s;
}
inline const std::string& PostRes::_internal_text() const {
  return _impl_.text_.Get();
}
inline void PostRes::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* PostRes::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* PostRes::release_text() {
  // @@protoc_insertion_point(field_release:weibo.PostRes.text)
  return _impl_.text_.Release();
}
inline void PostRes::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PostRes.text)
}

// string author_name = 3;
inline void PostRes::clear_author_name() {
  _impl_.author_name_.ClearToEmpty();
}
inline const std::string& PostRes::author_name() const {
  // @@protoc_insertion_point(field_get:weibo.PostRes.author_name)
  return _internal_author_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostRes::set_author_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PostRes.author_name)
}
inline std::string* PostRes::mutable_author_name() {
  std::string* _s = _internal_mutable_author_name();
  // @@protoc_insertion_point(field_mutable:weibo.PostRes.author_name)
  return _s;
}
inline const std::string& PostRes::_internal_author_name() const {
  return _impl_.author_name_.Get();
}
inline void PostRes::_internal_set_author_name(const std::string& value) {
  
  _impl_.author_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PostRes::_internal_mutable_author_name() {
  
  return _impl_.author_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PostRes::release_author_name() {
  // @@protoc_insertion_point(field_release:weibo.PostRes.author_name)
  return _impl_.author_name_.Release();
}
inline void PostRes::set_allocated_author_name(std::string* author_name) {
  if (author_name != nullptr) {
    
  } else {
    
  }
  _impl_.author_name_.SetAllocated(author_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_name_.IsDefault()) {
    _impl_.author_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PostRes.author_name)
}

// int32 trans_nums = 4;
inline void PostRes::clear_trans_nums() {
  _impl_.trans_nums_ = 0;
}
inline int32_t PostRes::_internal_trans_nums() const {
  return _impl_.trans_nums_;
}
inline int32_t PostRes::trans_nums() const {
  // @@protoc_insertion_point(field_get:weibo.PostRes.trans_nums)
  return _internal_trans_nums();
}
inline void PostRes::_internal_set_trans_nums(int32_t value) {
  
  _impl_.trans_nums_ = value;
}
inline void PostRes::set_trans_nums(int32_t value) {
  _internal_set_trans_nums(value);
  // @@protoc_insertion_point(field_set:weibo.PostRes.trans_nums)
}

// string publish_time = 5;
inline void PostRes::clear_publish_time() {
  _impl_.publish_time_.ClearToEmpty();
}
inline const std::string& PostRes::publish_time() const {
  // @@protoc_insertion_point(field_get:weibo.PostRes.publish_time)
  return _internal_publish_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostRes::set_publish_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publish_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PostRes.publish_time)
}
inline std::string* PostRes::mutable_publish_time() {
  std::string* _s = _internal_mutable_publish_time();
  // @@protoc_insertion_point(field_mutable:weibo.PostRes.publish_time)
  return _s;
}
inline const std::string& PostRes::_internal_publish_time() const {
  return _impl_.publish_time_.Get();
}
inline void PostRes::_internal_set_publish_time(const std::string& value) {
  
  _impl_.publish_time_.Set(value, GetArenaForAllocation());
}
inline std::string* PostRes::_internal_mutable_publish_time() {
  
  return _impl_.publish_time_.Mutable(GetArenaForAllocation());
}
inline std::string* PostRes::release_publish_time() {
  // @@protoc_insertion_point(field_release:weibo.PostRes.publish_time)
  return _impl_.publish_time_.Release();
}
inline void PostRes::set_allocated_publish_time(std::string* publish_time) {
  if (publish_time != nullptr) {
    
  } else {
    
  }
  _impl_.publish_time_.SetAllocated(publish_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publish_time_.IsDefault()) {
    _impl_.publish_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PostRes.publish_time)
}

// -------------------------------------------------------------------

// GetPostByUserIdReq

// uint32 user_id = 1;
inline void GetPostByUserIdReq::clear_user_id() {
  _impl_.user_id_ = 0u;
}
inline uint32_t GetPostByUserIdReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetPostByUserIdReq::user_id() const {
  // @@protoc_insertion_point(field_get:weibo.GetPostByUserIdReq.user_id)
  return _internal_user_id();
}
inline void GetPostByUserIdReq::_internal_set_user_id(uint32_t value) {
  
  _impl_.user_id_ = value;
}
inline void GetPostByUserIdReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:weibo.GetPostByUserIdReq.user_id)
}

// -------------------------------------------------------------------

// PostFeedReq

// int32 each_flush_post_num = 1;
inline void PostFeedReq::clear_each_flush_post_num() {
  _impl_.each_flush_post_num_ = 0;
}
inline int32_t PostFeedReq::_internal_each_flush_post_num() const {
  return _impl_.each_flush_post_num_;
}
inline int32_t PostFeedReq::each_flush_post_num() const {
  // @@protoc_insertion_point(field_get:weibo.PostFeedReq.each_flush_post_num)
  return _internal_each_flush_post_num();
}
inline void PostFeedReq::_internal_set_each_flush_post_num(int32_t value) {
  
  _impl_.each_flush_post_num_ = value;
}
inline void PostFeedReq::set_each_flush_post_num(int32_t value) {
  _internal_set_each_flush_post_num(value);
  // @@protoc_insertion_point(field_set:weibo.PostFeedReq.each_flush_post_num)
}

// string token = 2;
inline void PostFeedReq::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PostFeedReq::token() const {
  // @@protoc_insertion_point(field_get:weibo.PostFeedReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostFeedReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:weibo.PostFeedReq.token)
}
inline std::string* PostFeedReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:weibo.PostFeedReq.token)
  return _s;
}
inline const std::string& PostFeedReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PostFeedReq::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PostFeedReq::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PostFeedReq::release_token() {
  // @@protoc_insertion_point(field_release:weibo.PostFeedReq.token)
  return _impl_.token_.Release();
}
inline void PostFeedReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:weibo.PostFeedReq.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace weibo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_weibo_2eproto
